if isfile(joinpath(dirname(@__FILE__), "Defaults.jl"))
    warn("Unitful.jl factory defaults have been revised. Please consider ",
        "backing up the existing file at $(joinpath(dirname(@__FILE__),
        "Defaults.jl")), then run `Pkg.build(\"Unitful\")`.")
else
    info("Default units, dimensions, and logic are set in ",
        "$(escape_string(joinpath(dirname(@__FILE__), "Defaults.jl")))")
    open(joinpath(dirname(@__FILE__), "Defaults.jl"), "w") do f
        print(f, """
        # Default dimensions and their abbreviations.
        # The dimension symbols are generated by tab completion: \\mbfL is ğ‹, etc.
        # This is kind of a compromise on polluting the namespace.
        @dimension ğ‹ "ğ‹" Length
        @dimension ğŒ "ğŒ" Mass
        @dimension ğ“ "ğ“" Time
        @dimension ğˆ "ğˆ" Current
        @dimension ğš¯ "ğš¯" Temperature    # This one is \\mbfTheta
        @dimension ğ‰ "ğ‰" Luminosity
        @dimension ğ "ğ" Amount

        # Define derived dimensions.
        @derived_dimension Area             ğ‹^2
        @derived_dimension Volume           ğ‹^3
        @derived_dimension Frequency        inv(ğ“)
        @derived_dimension Force            ğŒ*ğ‹/ğ“^2
        @derived_dimension Pressure         ğŒ*ğ‹^-1*ğ“^-2
        @derived_dimension Energy           ğŒ*ğ‹^2/ğ“^2
        @derived_dimension Momentum         ğŒ*ğ‹/ğ“
        @derived_dimension Power            ğ‹^2*ğŒ*ğ“^-3
        @derived_dimension Charge           ğˆ*ğ“
        @derived_dimension Voltage          ğˆ^-1*ğ‹^2*ğŒ*ğ“^-3
        @derived_dimension Resistance       ğˆ^-2*ğ‹^2*ğŒ*ğ“^-3
        @derived_dimension Capacitance      ğˆ^2*ğ‹^-2*ğŒ^-1*ğ“^4
        @derived_dimension Inductance       ğˆ^-2*ğ‹^2*ğŒ*ğ“^-2
        @derived_dimension MagneticFlux     ğˆ^-1*ğ‹^2*ğŒ*ğ“^-2
        @derived_dimension HField           ğˆ/ğ‹
        @derived_dimension BField           ğˆ^-1*ğŒ*ğ“^-2

        # Define base units. This is not to imply g is the base SI unit instead of kg.
        # See the documentation for further details.
        # #key:   Symbol  Display  Name      Dimension   Prefixes?
        @refunit  m       "m"      Meter     ğ‹           true
        @refunit  s       "s"      Second    ğ“           true
        @refunit  A       "A"      Ampere    ğˆ            true
        @refunit  K       "K"      Kelvin    ğš¯           true
        @refunit  cd      "cd"     Candela   ğ‰            true
        @refunit  g       "g"      Gram      ğŒ           true
        @refunit  mol     "mol"    Mole      ğ           true

        # Specify preferred unit for promotion.
        # This is separate from the @refunit macro for flexibility; consider that
        # the SI unit of mass is not g but instead kg, and yet some people use cgs units.
        # This macro should only be used with units having "pure" dimensions like ğ‹, ğ“, ğˆ, etc.
        @preferunit m
        @preferunit s
        @preferunit A
        @preferunit K
        @preferunit cd
        @preferunit kg
        @preferunit mol

        # Length
        #key: Symbol Display    Name        Equivalent to           10^n prefixes?
        @unit mi     "mi"       Mile        (201168//125)*m         false
        @unit yd     "yd"       Yard        (9144//10000)*m         false
        @unit ft     "ft"       Foot        (3048//10000)*m         false
        @unit inch   "in"       Inch        (254//10000)*m          false

        # Area
        @unit ac     "ac"       Acre        (316160658//78125)*m^2  false
        @unit a      "a"        Are         100m^2                  false

        # The hectare is used more frequently than any other power-of-ten of an are.
        const ha = Unitful.Units{(Unitful.Unit{:Are}(2,1//1),), typeof(ğ‹)}()

        # Time
        @unit minute "min"      Minute      60s                     false
        @unit hr     "hr"       Hour        3600s                   false
        @unit d      "dy"       Day         86400s                  false
        @unit wk     "wk"       Week        604800s                 false

        # Angles and solid angles
        @unit sr      "sr"      Steradian   1                       true
        @unit rad     "rad"     Radian      1                       true
        @unit Â°       "Â°"       Degree      pi/180                  false
        import Base: sin, cos, tan, cot, sec, csc
        for _y in [:sin, :cos, :tan, :cot, :sec, :csc]
            @eval (\$_y)(x::DimensionlessQuantity) = (\$_y)(uconvert(NoUnits, x))
        end

        # Temperature
        @unit Â°Ra    "Â°Ra"      Rankine     (5//9)*K                false
        @unit Â°C     "Â°C"       Celsius     1K                      true
        Unitful.offsettemp(::Unitful.Unit{:Celsius}) = 27315//100
        @unit Â°F     "Â°F"       Fahrenheit  (5//9)*K                false
        Unitful.offsettemp(::Unitful.Unit{:Fahrenheit}) = 45967//100

        # SI and related units
        @unit N      "N"        Newton      1kg*m/s^2               true
        @unit Pa     "Pa"       Pascal      1N/m^2                  true
        @unit J      "J"        Joule       1N*m                    true
        @unit W      "W"        Watt        1J/s                    true
        @unit C      "C"        Coulomb     1A*s                    true
        @unit V      "V"        Volt        1W/A                    true
        @unit Hz     "Hz"       Hertz       1/s                     true
        const q = 1.6021766208e-19*C        # CODATA 2014; `e` means 2.718...
        @unit eV     "eV"       eV          q*V                     true
        @unit Î©      "Î©"        Ohm         1V/A                    true
        @unit S      "S"        Siemens     1/Î©                     true
        @unit F      "F"        Farad       1s^4*A^2/(kg*m^2)       true
        @unit H      "H"        Henry       1J/(A^2)                true
        @unit T      "T"        Tesla       1kg/(A*s^2)             true
        @unit Wb     "Wb"       Weber       1kg*m^2/(A*s^2)         true
        @unit lm     "lm"       Lumen       1cd*sr                  true
        @unit lx     "lx"       Lux         1lm/m^2                 true
        @unit Bq     "Bq"       Becquerel   1/s                     true
        @unit Gy     "Gy"       Gray        1J/kg                   true
        @unit Sv     "Sv"       Sievert     1J/kg                   true
        @unit kat    "kat"      Katal       1mol/s                  true

        # Constants (2014 CODATA values)    (uncertainties in final digits)
        const c0 = 299_792_458*m/s          # exact
        const c  = c0
        const Î¼0 = 4Ï€*(1//10)^7*H/m         # exact (but gets promoted to Float64...)
        const Âµ0 = Î¼0                       # magnetic constant
        const É›0 = 1/(Î¼0*c^2)               # exact, electric constant
        const Ïµ0 = É›0
        const Z0 = Î¼0*c                     # exact, impedance of free space
        const G  = 6.674_08e-11*m^3/kg/s^2  # (31) gravitational constant
        const h  = 6.626_070_040e-34*J*s    # (81) Planck constant
        const Ä§  = h/2Ï€                     # hbar
        const q  = 1.602_176_620_8e-19*C    # (98)  `e` means 2.718... so we use q
                                            # elementary charge
        const Î¦0 = h/(2q)                   # Superconducting magnetic flux quantum
        const me = 9.109_383_56e-31*kg      # (11) electron rest mass
        const mn = 1.674_927_471e-27*kg     # (21) neutron rest mass
        const mp = 1.672_621_898e-27*kg     # (21) proton rest mass
        const Î¼B = e*Ä§/(2*me)               # Bohr magneton
        const ÂµB = Î¼B
        const Na = 6.022_140_857e23/mol     # (74) Avogadro constant
        const R  = 8.314_459_8*J/(mol*K)    # (48) molar gass constant
        const k  = 1.380_648_52e-23*(J/K)   # (79) Boltzmann constant
        const Ïƒ  = Ï€^2*k^4/(60*Ä§^3*c^2)     # Stefan-Boltzmann constant

        # Promotion rules

        # By default, pick the units specified by the @preferunit macro.
        # Our use of promote_rule here is only via promote_type;
        # We will never be promoting unit objects themselves.
        function promote_rule{S<:DimensionedUnits,T<:DimensionedUnits}(::Type{S}, ::Type{T})
            dS = dimension(S())
            dT = dimension(T())
            dS != dT && error("Dimensions are unequal in call to `promote_rule`.")
            typeof(upreferred(dS))
        end

        # You could also add rules like the following, which will not interfere with
        # the generic behavior for other dimensions:
        promote_rule{S<:EnergyUnit, T<:EnergyUnit}(::Type{S}, ::Type{T}) = typeof(J)
        promote_rule{S<:ForceUnit, T<:ForceUnit}(::Type{S}, ::Type{T}) = typeof(N)
        promote_rule{S<:PowerUnit, T<:PowerUnit}(::Type{S}, ::Type{T}) = typeof(W)
        promote_rule{S<:PressureUnit, T<:PressureUnit}(::Type{S}, ::Type{T}) = typeof(Pa)
        promote_rule{S<:ChargeUnit, T<:ChargeUnit}(::Type{S}, ::Type{T}) = typeof(C)
        promote_rule{S<:VoltageUnit, T<:VoltageUnit}(::Type{S}, ::Type{T}) = typeof(V)
        promote_rule{S<:ResistanceUnit, T<:ResistanceUnit}(::Type{S}, ::Type{T}) = typeof(Î©)
        promote_rule{S<:CapacitanceUnit, T<:CapacitanceUnit}(::Type{S}, ::Type{T}) = typeof(F)
        promote_rule{S<:InductanceUnit, T<:InductanceUnit}(::Type{S}, ::Type{T}) = typeof(H)
        promote_rule{S<:MagneticFluxUnit, T<:MagneticFluxUnit}(::Type{S}, ::Type{T}) = typeof(Wb)
        promote_rule{S<:BFieldUnit, T<:BFieldUnit}(::Type{S}, ::Type{T}) = typeof(T)

        const si_no_prefix = (:m, :s, :A, :K, :cd, :g, :mol, :rad, :sr, :Hz, :N, :Pa,
            :J, :W, :C, :V, :F, :Î©, :S, :Wb, :T, :H, :Â°C, :lm, :lx, :Bq, :Gy, :Sv, :kat)

        # These lines allow for Î¼ to be typed with option-m on a Mac.
        const macmu = :Âµ
        const unicodemu = :Î¼
        for u in si_no_prefix
            eval(Unitful,
                Expr(:const, Expr(:(=), Symbol(macmu, u), Symbol(unicodemu, u))))
        end

        # `using Unitful.SIUnits` will bring all the base and derived SI units,
        # with SI prefixes, into the calling namespace.
        baremodule SIUnits
            import Unitful
            import Unitful: si_no_prefix

            # The following line has two different character encodings for Î¼
            for p in (:y, :z, :a, :f, :p, :n, :Î¼, :Âµ, :m, :c, :d,
                Symbol(""), :da, :h, :k, :M, :G, :T, :P, :E, :Z, :Y)
                for u in si_no_prefix
                    eval(SIUnits, Expr(:import, :Unitful, Symbol(p,u)))
                    eval(SIUnits, Expr(:export, Symbol(p,u)))
                end
            end
        end
        """)
    end
end
